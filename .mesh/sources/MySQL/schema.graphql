schema @transport(subgraph: "MySQL", kind: "mysql", location: "mysql://root:yaalimadad18@localhost:3306/AI_Assistant_DB") {
  query: Query
  mutation: Mutation
}

directive @transport(subgraph: String, kind: String, location: String) repeatable on SCHEMA

directive @mysqlSelect(subgraph: String, table: String, columnMap: [[String]]) on FIELD_DEFINITION

directive @mysqlInsert(subgraph: String, table: String, primaryKeys: [String]) on FIELD_DEFINITION

directive @mysqlUpdate(subgraph: String, table: String, columnMap: [[String]]) on FIELD_DEFINITION

directive @mysqlDelete(subgraph: String, table: String) on FIELD_DEFINITION

directive @mysqlTableForeign(subgraph: String, columnName: String) on FIELD_DEFINITION

directive @mysqlCount(subgraph: String, table: String) on FIELD_DEFINITION

type Query {
  accounts(limit: Int, offset: Int, where: accounts_WhereInput, orderBy: accounts_OrderByInput): [accounts] @mysqlSelect(subgraph: "MySQL", table: "accounts")
  count_accounts(where: accounts_WhereInput): Int @mysqlCount(subgraph: "MySQL", table: "accounts")
  cleanup_suggestions(limit: Int, offset: Int, where: cleanup_suggestions_WhereInput, orderBy: cleanup_suggestions_OrderByInput): [cleanup_suggestions] @mysqlSelect(subgraph: "MySQL", table: "cleanup_suggestions")
  count_cleanup_suggestions(where: cleanup_suggestions_WhereInput): Int @mysqlCount(subgraph: "MySQL", table: "cleanup_suggestions")
  sessions(limit: Int, offset: Int, where: sessions_WhereInput, orderBy: sessions_OrderByInput): [sessions] @mysqlSelect(subgraph: "MySQL", table: "sessions")
  count_sessions(where: sessions_WhereInput): Int @mysqlCount(subgraph: "MySQL", table: "sessions")
  user_calendar_events(limit: Int, offset: Int, where: user_calendar_events_WhereInput, orderBy: user_calendar_events_OrderByInput): [user_calendar_events] @mysqlSelect(subgraph: "MySQL", table: "user_calendar_events")
  count_user_calendar_events(where: user_calendar_events_WhereInput): Int @mysqlCount(subgraph: "MySQL", table: "user_calendar_events")
  user_emails(limit: Int, offset: Int, where: user_emails_WhereInput, orderBy: user_emails_OrderByInput): [user_emails] @mysqlSelect(subgraph: "MySQL", table: "user_emails")
  count_user_emails(where: user_emails_WhereInput): Int @mysqlCount(subgraph: "MySQL", table: "user_emails")
  user_preferences(limit: Int, offset: Int, where: user_preferences_WhereInput, orderBy: user_preferences_OrderByInput): [user_preferences] @mysqlSelect(subgraph: "MySQL", table: "user_preferences")
  count_user_preferences(where: user_preferences_WhereInput): Int @mysqlCount(subgraph: "MySQL", table: "user_preferences")
  users(limit: Int, offset: Int, where: users_WhereInput, orderBy: users_OrderByInput): [users] @mysqlSelect(subgraph: "MySQL", table: "users")
  count_users(where: users_WhereInput): Int @mysqlCount(subgraph: "MySQL", table: "users")
}

type accounts {
  """Unique ID for this specific account link (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """Type of account (e.g., 'oauth', 'email', 'credentials')"""
  type: String!
  """The OAuth provider name (e.g., 'google', 'azure-ad')"""
  provider: String!
  """
  The unique ID of the user from the OAuth provider (e.g., Google's internal user ID)
  """
  provider_account_id: String!
  """
  Encrypted refresh token from the OAuth provider, used to get new access tokens
  """
  refresh_token: String
  """Encrypted access token from the OAuth provider, used for API calls"""
  access_token: String
  """Unix timestamp (seconds) when the access token expires"""
  expires_at: BigInt
  """e.g., 'Bearer'"""
  token_type: String
  """
  The specific scopes (permissions) granted for this provider connection (e.g., gmail.modify, calendar.events)
  """
  scope: String
  """The ID Token from OAuth (JWT), if provided by the provider"""
  id_token: String
  """For OAuth 2.0 state management"""
  session_state: String
  created_at: Timestamp
  updated_at: Timestamp
  users(where: users_WhereInput, orderBy: users_OrderByInput, limit: Int, offset: Int): [users] @mysqlSelect(subgraph: "MySQL", table: "users", columnMap: [["id", "user_id"]]) @mysqlTableForeign(subgraph: "MySQL", columnName: "user_id")
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type users {
  """
  Unique user ID (UUID) generated by NextAuth.js for your application's internal use
  """
  id: String!
  """User's display name, typically from the OAuth provider (e.g., Google)"""
  name: String
  """
  User's primary email address, typically from the OAuth provider (e.g., Google)
  """
  email: String!
  """Timestamp when the email was verified (e.g., via OAuth login)"""
  email_verified: DateTime
  """URL to user's profile picture from the OAuth provider"""
  image: String
  """Timestamp when the user record was created"""
  created_at: Timestamp
  """Timestamp when the user record was last updated"""
  updated_at: Timestamp
  """Last time user data was polled for new emails/events"""
  last_synced_at: DateTime
  has_synced: Int
  accounts(limit: Int, offset: Int, where: accounts_WhereInput, orderBy: accounts_OrderByInput): [accounts] @mysqlSelect(subgraph: "MySQL", table: "accounts", columnMap: [["user_id", "id"]])
  cleanup_suggestions(limit: Int, offset: Int, where: cleanup_suggestions_WhereInput, orderBy: cleanup_suggestions_OrderByInput): [cleanup_suggestions] @mysqlSelect(subgraph: "MySQL", table: "cleanup_suggestions", columnMap: [["user_id", "id"]])
  sessions(limit: Int, offset: Int, where: sessions_WhereInput, orderBy: sessions_OrderByInput): [sessions] @mysqlSelect(subgraph: "MySQL", table: "sessions", columnMap: [["user_id", "id"]])
  user_calendar_events(limit: Int, offset: Int, where: user_calendar_events_WhereInput, orderBy: user_calendar_events_OrderByInput): [user_calendar_events] @mysqlSelect(subgraph: "MySQL", table: "user_calendar_events", columnMap: [["user_id", "id"]])
  user_emails(limit: Int, offset: Int, where: user_emails_WhereInput, orderBy: user_emails_OrderByInput): [user_emails] @mysqlSelect(subgraph: "MySQL", table: "user_emails", columnMap: [["user_id", "id"]])
  user_preferences(limit: Int, offset: Int, where: user_preferences_WhereInput, orderBy: user_preferences_OrderByInput): [user_preferences] @mysqlSelect(subgraph: "MySQL", table: "user_preferences", columnMap: [["user_id", "id"]])
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input accounts_WhereInput {
  """Unique ID for this specific account link (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """Type of account (e.g., 'oauth', 'email', 'credentials')"""
  type: String
  """The OAuth provider name (e.g., 'google', 'azure-ad')"""
  provider: String
  """
  The unique ID of the user from the OAuth provider (e.g., Google's internal user ID)
  """
  provider_account_id: String
  """
  Encrypted refresh token from the OAuth provider, used to get new access tokens
  """
  refresh_token: String
  """Encrypted access token from the OAuth provider, used for API calls"""
  access_token: String
  """Unix timestamp (seconds) when the access token expires"""
  expires_at: String
  """e.g., 'Bearer'"""
  token_type: String
  """
  The specific scopes (permissions) granted for this provider connection (e.g., gmail.modify, calendar.events)
  """
  scope: String
  """The ID Token from OAuth (JWT), if provided by the provider"""
  id_token: String
  """For OAuth 2.0 state management"""
  session_state: String
  created_at: String
  updated_at: String
}

input accounts_OrderByInput {
  """Unique ID for this specific account link (UUID)"""
  id: OrderBy
  """Foreign key linking to the users table"""
  user_id: OrderBy
  """Type of account (e.g., 'oauth', 'email', 'credentials')"""
  type: OrderBy
  """The OAuth provider name (e.g., 'google', 'azure-ad')"""
  provider: OrderBy
  """
  The unique ID of the user from the OAuth provider (e.g., Google's internal user ID)
  """
  provider_account_id: OrderBy
  """
  Encrypted refresh token from the OAuth provider, used to get new access tokens
  """
  refresh_token: OrderBy
  """Encrypted access token from the OAuth provider, used for API calls"""
  access_token: OrderBy
  """Unix timestamp (seconds) when the access token expires"""
  expires_at: OrderBy
  """e.g., 'Bearer'"""
  token_type: OrderBy
  """
  The specific scopes (permissions) granted for this provider connection (e.g., gmail.modify, calendar.events)
  """
  scope: OrderBy
  """The ID Token from OAuth (JWT), if provided by the provider"""
  id_token: OrderBy
  """For OAuth 2.0 state management"""
  session_state: OrderBy
  created_at: OrderBy
  updated_at: OrderBy
}

enum OrderBy {
  asc
  desc
}

type cleanup_suggestions {
  """Unique ID for the suggestion (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """Foreign key linking to the user_emails table"""
  email_id: String!
  """The email's ID from Google/Outlook"""
  provider_email_id: String!
  """Sender's email address"""
  from_email: String
  """Email subject line"""
  subject: String
  """A short preview/snippet of the email body"""
  snippet: String
  """Reason for the cleanup suggestion"""
  reason: String!
  """Suggested cleanup action"""
  suggested_action: cleanup_suggestions_suggested_action!
  """Current status of the suggestion"""
  status: cleanup_suggestions_status
  """Timestamp when the suggestion was created"""
  created_at: Timestamp
  """Timestamp when the suggestion was last updated"""
  updated_at: Timestamp
  user_emails(where: user_emails_WhereInput, orderBy: user_emails_OrderByInput, limit: Int, offset: Int): [user_emails] @mysqlSelect(subgraph: "MySQL", table: "user_emails", columnMap: [["id", "email_id"]]) @mysqlTableForeign(subgraph: "MySQL", columnName: "email_id")
  users(where: users_WhereInput, orderBy: users_OrderByInput, limit: Int, offset: Int): [users] @mysqlSelect(subgraph: "MySQL", table: "users", columnMap: [["id", "user_id"]]) @mysqlTableForeign(subgraph: "MySQL", columnName: "user_id")
}

enum cleanup_suggestions_suggested_action {
  archive
  trash
  delete_permanently
}

enum cleanup_suggestions_status {
  pending
  approved
  rejected
  executed
}

type user_emails {
  """Your internal unique ID for the email (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """The email's ID from Google/Outlook (e.g., Gmail's message ID)"""
  provider_email_id: String!
  """The thread ID from the provider"""
  thread_id: String
  """Sender's email address"""
  from_email: String
  """JSON array of recipient email addresses"""
  to_emails: JSON
  """JSON array of CC recipient email addresses"""
  cc_emails: JSON
  """JSON array of BCC recipient email addresses"""
  bcc_emails: JSON
  """Email subject line"""
  subject: String
  """A short preview/snippet of the email body"""
  snippet: String
  """The internal date/time from the email provider"""
  internal_date: DateTime
  """Timestamp when your system ingested this email"""
  received_at: Timestamp
  """Whether the email is marked as read"""
  is_read: Int
  """JSON array of label IDs (e.g., 'INBOX', 'SENT', 'STARRED')"""
  label_ids: JSON
  """Current status of the email in the mailbox"""
  status: user_emails_status
  """SHA256 hash of the full email body to detect changes (optional)"""
  raw_body_hash: String
  created_at: Timestamp
  updated_at: Timestamp
  cleanup_suggestions(limit: Int, offset: Int, where: cleanup_suggestions_WhereInput, orderBy: cleanup_suggestions_OrderByInput): [cleanup_suggestions] @mysqlSelect(subgraph: "MySQL", table: "cleanup_suggestions", columnMap: [["email_id", "id"]])
  users(where: users_WhereInput, orderBy: users_OrderByInput, limit: Int, offset: Int): [users] @mysqlSelect(subgraph: "MySQL", table: "users", columnMap: [["id", "user_id"]]) @mysqlTableForeign(subgraph: "MySQL", columnName: "user_id")
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

enum user_emails_status {
  active
  archived
  trashed
  deleted
}

input cleanup_suggestions_WhereInput {
  """Unique ID for the suggestion (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """Foreign key linking to the user_emails table"""
  email_id: String
  """The email's ID from Google/Outlook"""
  provider_email_id: String
  """Sender's email address"""
  from_email: String
  """Email subject line"""
  subject: String
  """A short preview/snippet of the email body"""
  snippet: String
  """Reason for the cleanup suggestion"""
  reason: String
  """Suggested cleanup action"""
  suggested_action: String
  """Current status of the suggestion"""
  status: String
  """Timestamp when the suggestion was created"""
  created_at: String
  """Timestamp when the suggestion was last updated"""
  updated_at: String
}

input cleanup_suggestions_OrderByInput {
  """Unique ID for the suggestion (UUID)"""
  id: OrderBy
  """Foreign key linking to the users table"""
  user_id: OrderBy
  """Foreign key linking to the user_emails table"""
  email_id: OrderBy
  """The email's ID from Google/Outlook"""
  provider_email_id: OrderBy
  """Sender's email address"""
  from_email: OrderBy
  """Email subject line"""
  subject: OrderBy
  """A short preview/snippet of the email body"""
  snippet: OrderBy
  """Reason for the cleanup suggestion"""
  reason: OrderBy
  """Suggested cleanup action"""
  suggested_action: OrderBy
  """Current status of the suggestion"""
  status: OrderBy
  """Timestamp when the suggestion was created"""
  created_at: OrderBy
  """Timestamp when the suggestion was last updated"""
  updated_at: OrderBy
}

input users_WhereInput {
  """
  Unique user ID (UUID) generated by NextAuth.js for your application's internal use
  """
  id: String
  """User's display name, typically from the OAuth provider (e.g., Google)"""
  name: String
  """
  User's primary email address, typically from the OAuth provider (e.g., Google)
  """
  email: String
  """Timestamp when the email was verified (e.g., via OAuth login)"""
  email_verified: String
  """URL to user's profile picture from the OAuth provider"""
  image: String
  """Timestamp when the user record was created"""
  created_at: String
  """Timestamp when the user record was last updated"""
  updated_at: String
  """Last time user data was polled for new emails/events"""
  last_synced_at: String
  has_synced: String
}

input users_OrderByInput {
  """
  Unique user ID (UUID) generated by NextAuth.js for your application's internal use
  """
  id: OrderBy
  """User's display name, typically from the OAuth provider (e.g., Google)"""
  name: OrderBy
  """
  User's primary email address, typically from the OAuth provider (e.g., Google)
  """
  email: OrderBy
  """Timestamp when the email was verified (e.g., via OAuth login)"""
  email_verified: OrderBy
  """URL to user's profile picture from the OAuth provider"""
  image: OrderBy
  """Timestamp when the user record was created"""
  created_at: OrderBy
  """Timestamp when the user record was last updated"""
  updated_at: OrderBy
  """Last time user data was polled for new emails/events"""
  last_synced_at: OrderBy
  has_synced: OrderBy
}

input user_emails_WhereInput {
  """Your internal unique ID for the email (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """The email's ID from Google/Outlook (e.g., Gmail's message ID)"""
  provider_email_id: String
  """The thread ID from the provider"""
  thread_id: String
  """Sender's email address"""
  from_email: String
  """JSON array of recipient email addresses"""
  to_emails: String
  """JSON array of CC recipient email addresses"""
  cc_emails: String
  """JSON array of BCC recipient email addresses"""
  bcc_emails: String
  """Email subject line"""
  subject: String
  """A short preview/snippet of the email body"""
  snippet: String
  """The internal date/time from the email provider"""
  internal_date: String
  """Timestamp when your system ingested this email"""
  received_at: String
  """Whether the email is marked as read"""
  is_read: String
  """JSON array of label IDs (e.g., 'INBOX', 'SENT', 'STARRED')"""
  label_ids: String
  """Current status of the email in the mailbox"""
  status: String
  """SHA256 hash of the full email body to detect changes (optional)"""
  raw_body_hash: String
  created_at: String
  updated_at: String
}

input user_emails_OrderByInput {
  """Your internal unique ID for the email (UUID)"""
  id: OrderBy
  """Foreign key linking to the users table"""
  user_id: OrderBy
  """The email's ID from Google/Outlook (e.g., Gmail's message ID)"""
  provider_email_id: OrderBy
  """The thread ID from the provider"""
  thread_id: OrderBy
  """Sender's email address"""
  from_email: OrderBy
  """JSON array of recipient email addresses"""
  to_emails: OrderBy
  """JSON array of CC recipient email addresses"""
  cc_emails: OrderBy
  """JSON array of BCC recipient email addresses"""
  bcc_emails: OrderBy
  """Email subject line"""
  subject: OrderBy
  """A short preview/snippet of the email body"""
  snippet: OrderBy
  """The internal date/time from the email provider"""
  internal_date: OrderBy
  """Timestamp when your system ingested this email"""
  received_at: OrderBy
  """Whether the email is marked as read"""
  is_read: OrderBy
  """JSON array of label IDs (e.g., 'INBOX', 'SENT', 'STARRED')"""
  label_ids: OrderBy
  """Current status of the email in the mailbox"""
  status: OrderBy
  """SHA256 hash of the full email body to detect changes (optional)"""
  raw_body_hash: OrderBy
  created_at: OrderBy
  updated_at: OrderBy
}

type sessions {
  """Unique ID for the session record (UUID)"""
  id: String!
  """The unique token used to identify the session"""
  session_token: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """Timestamp when the session expires"""
  expires: DateTime!
  created_at: Timestamp
  updated_at: Timestamp
  users(where: users_WhereInput, orderBy: users_OrderByInput, limit: Int, offset: Int): [users] @mysqlSelect(subgraph: "MySQL", table: "users", columnMap: [["id", "user_id"]]) @mysqlTableForeign(subgraph: "MySQL", columnName: "user_id")
}

input sessions_WhereInput {
  """Unique ID for the session record (UUID)"""
  id: String
  """The unique token used to identify the session"""
  session_token: String
  """Foreign key linking to the users table"""
  user_id: String
  """Timestamp when the session expires"""
  expires: String
  created_at: String
  updated_at: String
}

input sessions_OrderByInput {
  """Unique ID for the session record (UUID)"""
  id: OrderBy
  """The unique token used to identify the session"""
  session_token: OrderBy
  """Foreign key linking to the users table"""
  user_id: OrderBy
  """Timestamp when the session expires"""
  expires: OrderBy
  created_at: OrderBy
  updated_at: OrderBy
}

type user_calendar_events {
  """Your internal unique ID for the event (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """The event's ID from Google/Outlook"""
  provider_event_id: String!
  """The ID of the calendar it belongs to"""
  calendar_id: String!
  """Event title/summary"""
  summary: String
  """Event description"""
  description: String
  """Event start time"""
  start_time: DateTime!
  """Event end time"""
  end_time: DateTime!
  """Event location"""
  location: String
  """JSON array of attendee emails and their response statuses"""
  attendees: JSON
  """Event status"""
  status: user_calendar_events_status!
  """
  Link to the event in the provider's calendar (e.g., Google Calendar HTML link)
  """
  html_link: String
  """Timestamp when your system ingested this event"""
  ingested_at: Timestamp
  created_at: Timestamp
  updated_at: Timestamp
  users(where: users_WhereInput, orderBy: users_OrderByInput, limit: Int, offset: Int): [users] @mysqlSelect(subgraph: "MySQL", table: "users", columnMap: [["id", "user_id"]]) @mysqlTableForeign(subgraph: "MySQL", columnName: "user_id")
}

enum user_calendar_events_status {
  confirmed
  tentative
  cancelled
}

input user_calendar_events_WhereInput {
  """Your internal unique ID for the event (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """The event's ID from Google/Outlook"""
  provider_event_id: String
  """The ID of the calendar it belongs to"""
  calendar_id: String
  """Event title/summary"""
  summary: String
  """Event description"""
  description: String
  """Event start time"""
  start_time: String
  """Event end time"""
  end_time: String
  """Event location"""
  location: String
  """JSON array of attendee emails and their response statuses"""
  attendees: String
  """Event status"""
  status: String
  """
  Link to the event in the provider's calendar (e.g., Google Calendar HTML link)
  """
  html_link: String
  """Timestamp when your system ingested this event"""
  ingested_at: String
  created_at: String
  updated_at: String
}

input user_calendar_events_OrderByInput {
  """Your internal unique ID for the event (UUID)"""
  id: OrderBy
  """Foreign key linking to the users table"""
  user_id: OrderBy
  """The event's ID from Google/Outlook"""
  provider_event_id: OrderBy
  """The ID of the calendar it belongs to"""
  calendar_id: OrderBy
  """Event title/summary"""
  summary: OrderBy
  """Event description"""
  description: OrderBy
  """Event start time"""
  start_time: OrderBy
  """Event end time"""
  end_time: OrderBy
  """Event location"""
  location: OrderBy
  """JSON array of attendee emails and their response statuses"""
  attendees: OrderBy
  """Event status"""
  status: OrderBy
  """
  Link to the event in the provider's calendar (e.g., Google Calendar HTML link)
  """
  html_link: OrderBy
  """Timestamp when your system ingested this event"""
  ingested_at: OrderBy
  created_at: OrderBy
  updated_at: OrderBy
}

type user_preferences {
  """Unique ID for the preference record (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """
  Key for the specific preference (e.g., 'ai_tone', 'auto_summarize', 'email_unwanted_senders')
  """
  preference_key: String!
  """
  Value of the preference (e.g., 'professional', 'true', '15', '["spam.com", "newsletter.net"]')
  """
  preference_value: String
  created_at: Timestamp
  updated_at: Timestamp
  users(where: users_WhereInput, orderBy: users_OrderByInput, limit: Int, offset: Int): [users] @mysqlSelect(subgraph: "MySQL", table: "users", columnMap: [["id", "user_id"]]) @mysqlTableForeign(subgraph: "MySQL", columnName: "user_id")
}

input user_preferences_WhereInput {
  """Unique ID for the preference record (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """
  Key for the specific preference (e.g., 'ai_tone', 'auto_summarize', 'email_unwanted_senders')
  """
  preference_key: String
  """
  Value of the preference (e.g., 'professional', 'true', '15', '["spam.com", "newsletter.net"]')
  """
  preference_value: String
  created_at: String
  updated_at: String
}

input user_preferences_OrderByInput {
  """Unique ID for the preference record (UUID)"""
  id: OrderBy
  """Foreign key linking to the users table"""
  user_id: OrderBy
  """
  Key for the specific preference (e.g., 'ai_tone', 'auto_summarize', 'email_unwanted_senders')
  """
  preference_key: OrderBy
  """
  Value of the preference (e.g., 'professional', 'true', '15', '["spam.com", "newsletter.net"]')
  """
  preference_value: OrderBy
  created_at: OrderBy
  updated_at: OrderBy
}

type Mutation {
  insert_accounts(accounts: accounts_InsertInput!): accounts @mysqlInsert(subgraph: "MySQL", table: "accounts", primaryKeys: ["id"])
  update_accounts(accounts: accounts_UpdateInput!, where: accounts_WhereInput): accounts @mysqlUpdate(subgraph: "MySQL", table: "accounts")
  delete_accounts(where: accounts_WhereInput): Boolean @mysqlDelete(subgraph: "MySQL", table: "accounts")
  insert_cleanup_suggestions(cleanup_suggestions: cleanup_suggestions_InsertInput!): cleanup_suggestions @mysqlInsert(subgraph: "MySQL", table: "cleanup_suggestions", primaryKeys: ["id"])
  update_cleanup_suggestions(cleanup_suggestions: cleanup_suggestions_UpdateInput!, where: cleanup_suggestions_WhereInput): cleanup_suggestions @mysqlUpdate(subgraph: "MySQL", table: "cleanup_suggestions")
  delete_cleanup_suggestions(where: cleanup_suggestions_WhereInput): Boolean @mysqlDelete(subgraph: "MySQL", table: "cleanup_suggestions")
  insert_sessions(sessions: sessions_InsertInput!): sessions @mysqlInsert(subgraph: "MySQL", table: "sessions", primaryKeys: ["id"])
  update_sessions(sessions: sessions_UpdateInput!, where: sessions_WhereInput): sessions @mysqlUpdate(subgraph: "MySQL", table: "sessions")
  delete_sessions(where: sessions_WhereInput): Boolean @mysqlDelete(subgraph: "MySQL", table: "sessions")
  insert_user_calendar_events(user_calendar_events: user_calendar_events_InsertInput!): user_calendar_events @mysqlInsert(subgraph: "MySQL", table: "user_calendar_events", primaryKeys: ["id"])
  update_user_calendar_events(user_calendar_events: user_calendar_events_UpdateInput!, where: user_calendar_events_WhereInput): user_calendar_events @mysqlUpdate(subgraph: "MySQL", table: "user_calendar_events")
  delete_user_calendar_events(where: user_calendar_events_WhereInput): Boolean @mysqlDelete(subgraph: "MySQL", table: "user_calendar_events")
  insert_user_emails(user_emails: user_emails_InsertInput!): user_emails @mysqlInsert(subgraph: "MySQL", table: "user_emails", primaryKeys: ["id"])
  update_user_emails(user_emails: user_emails_UpdateInput!, where: user_emails_WhereInput): user_emails @mysqlUpdate(subgraph: "MySQL", table: "user_emails")
  delete_user_emails(where: user_emails_WhereInput): Boolean @mysqlDelete(subgraph: "MySQL", table: "user_emails")
  insert_user_preferences(user_preferences: user_preferences_InsertInput!): user_preferences @mysqlInsert(subgraph: "MySQL", table: "user_preferences", primaryKeys: ["id"])
  update_user_preferences(user_preferences: user_preferences_UpdateInput!, where: user_preferences_WhereInput): user_preferences @mysqlUpdate(subgraph: "MySQL", table: "user_preferences")
  delete_user_preferences(where: user_preferences_WhereInput): Boolean @mysqlDelete(subgraph: "MySQL", table: "user_preferences")
  insert_users(users: users_InsertInput!): users @mysqlInsert(subgraph: "MySQL", table: "users", primaryKeys: ["id"])
  update_users(users: users_UpdateInput!, where: users_WhereInput): users @mysqlUpdate(subgraph: "MySQL", table: "users")
  delete_users(where: users_WhereInput): Boolean @mysqlDelete(subgraph: "MySQL", table: "users")
}

input accounts_InsertInput {
  """Unique ID for this specific account link (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """Type of account (e.g., 'oauth', 'email', 'credentials')"""
  type: String!
  """The OAuth provider name (e.g., 'google', 'azure-ad')"""
  provider: String!
  """
  The unique ID of the user from the OAuth provider (e.g., Google's internal user ID)
  """
  provider_account_id: String!
  """
  Encrypted refresh token from the OAuth provider, used to get new access tokens
  """
  refresh_token: String
  """Encrypted access token from the OAuth provider, used for API calls"""
  access_token: String
  """Unix timestamp (seconds) when the access token expires"""
  expires_at: BigInt
  """e.g., 'Bearer'"""
  token_type: String
  """
  The specific scopes (permissions) granted for this provider connection (e.g., gmail.modify, calendar.events)
  """
  scope: String
  """The ID Token from OAuth (JWT), if provided by the provider"""
  id_token: String
  """For OAuth 2.0 state management"""
  session_state: String
  created_at: Timestamp
  updated_at: Timestamp
}

input accounts_UpdateInput {
  """Unique ID for this specific account link (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """Type of account (e.g., 'oauth', 'email', 'credentials')"""
  type: String
  """The OAuth provider name (e.g., 'google', 'azure-ad')"""
  provider: String
  """
  The unique ID of the user from the OAuth provider (e.g., Google's internal user ID)
  """
  provider_account_id: String
  """
  Encrypted refresh token from the OAuth provider, used to get new access tokens
  """
  refresh_token: String
  """Encrypted access token from the OAuth provider, used for API calls"""
  access_token: String
  """Unix timestamp (seconds) when the access token expires"""
  expires_at: BigInt
  """e.g., 'Bearer'"""
  token_type: String
  """
  The specific scopes (permissions) granted for this provider connection (e.g., gmail.modify, calendar.events)
  """
  scope: String
  """The ID Token from OAuth (JWT), if provided by the provider"""
  id_token: String
  """For OAuth 2.0 state management"""
  session_state: String
  created_at: Timestamp
  updated_at: Timestamp
}

input cleanup_suggestions_InsertInput {
  """Unique ID for the suggestion (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """Foreign key linking to the user_emails table"""
  email_id: String!
  """The email's ID from Google/Outlook"""
  provider_email_id: String!
  """Sender's email address"""
  from_email: String
  """Email subject line"""
  subject: String
  """A short preview/snippet of the email body"""
  snippet: String
  """Reason for the cleanup suggestion"""
  reason: String!
  """Suggested cleanup action"""
  suggested_action: cleanup_suggestions_suggested_action!
  """Current status of the suggestion"""
  status: cleanup_suggestions_status
  """Timestamp when the suggestion was created"""
  created_at: Timestamp
  """Timestamp when the suggestion was last updated"""
  updated_at: Timestamp
}

input cleanup_suggestions_UpdateInput {
  """Unique ID for the suggestion (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """Foreign key linking to the user_emails table"""
  email_id: String
  """The email's ID from Google/Outlook"""
  provider_email_id: String
  """Sender's email address"""
  from_email: String
  """Email subject line"""
  subject: String
  """A short preview/snippet of the email body"""
  snippet: String
  """Reason for the cleanup suggestion"""
  reason: String
  """Suggested cleanup action"""
  suggested_action: cleanup_suggestions_suggested_action
  """Current status of the suggestion"""
  status: cleanup_suggestions_status
  """Timestamp when the suggestion was created"""
  created_at: Timestamp
  """Timestamp when the suggestion was last updated"""
  updated_at: Timestamp
}

input sessions_InsertInput {
  """Unique ID for the session record (UUID)"""
  id: String!
  """The unique token used to identify the session"""
  session_token: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """Timestamp when the session expires"""
  expires: DateTime!
  created_at: Timestamp
  updated_at: Timestamp
}

input sessions_UpdateInput {
  """Unique ID for the session record (UUID)"""
  id: String
  """The unique token used to identify the session"""
  session_token: String
  """Foreign key linking to the users table"""
  user_id: String
  """Timestamp when the session expires"""
  expires: DateTime
  created_at: Timestamp
  updated_at: Timestamp
}

input user_calendar_events_InsertInput {
  """Your internal unique ID for the event (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """The event's ID from Google/Outlook"""
  provider_event_id: String!
  """The ID of the calendar it belongs to"""
  calendar_id: String!
  """Event title/summary"""
  summary: String
  """Event description"""
  description: String
  """Event start time"""
  start_time: DateTime!
  """Event end time"""
  end_time: DateTime!
  """Event location"""
  location: String
  """JSON array of attendee emails and their response statuses"""
  attendees: JSON
  """Event status"""
  status: user_calendar_events_status!
  """
  Link to the event in the provider's calendar (e.g., Google Calendar HTML link)
  """
  html_link: String
  """Timestamp when your system ingested this event"""
  ingested_at: Timestamp
  created_at: Timestamp
  updated_at: Timestamp
}

input user_calendar_events_UpdateInput {
  """Your internal unique ID for the event (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """The event's ID from Google/Outlook"""
  provider_event_id: String
  """The ID of the calendar it belongs to"""
  calendar_id: String
  """Event title/summary"""
  summary: String
  """Event description"""
  description: String
  """Event start time"""
  start_time: DateTime
  """Event end time"""
  end_time: DateTime
  """Event location"""
  location: String
  """JSON array of attendee emails and their response statuses"""
  attendees: JSON
  """Event status"""
  status: user_calendar_events_status
  """
  Link to the event in the provider's calendar (e.g., Google Calendar HTML link)
  """
  html_link: String
  """Timestamp when your system ingested this event"""
  ingested_at: Timestamp
  created_at: Timestamp
  updated_at: Timestamp
}

input user_emails_InsertInput {
  """Your internal unique ID for the email (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """The email's ID from Google/Outlook (e.g., Gmail's message ID)"""
  provider_email_id: String!
  """The thread ID from the provider"""
  thread_id: String
  """Sender's email address"""
  from_email: String
  """JSON array of recipient email addresses"""
  to_emails: JSON
  """JSON array of CC recipient email addresses"""
  cc_emails: JSON
  """JSON array of BCC recipient email addresses"""
  bcc_emails: JSON
  """Email subject line"""
  subject: String
  """A short preview/snippet of the email body"""
  snippet: String
  """The internal date/time from the email provider"""
  internal_date: DateTime
  """Timestamp when your system ingested this email"""
  received_at: Timestamp
  """Whether the email is marked as read"""
  is_read: Int
  """JSON array of label IDs (e.g., 'INBOX', 'SENT', 'STARRED')"""
  label_ids: JSON
  """Current status of the email in the mailbox"""
  status: user_emails_status
  """SHA256 hash of the full email body to detect changes (optional)"""
  raw_body_hash: String
  created_at: Timestamp
  updated_at: Timestamp
}

input user_emails_UpdateInput {
  """Your internal unique ID for the email (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """The email's ID from Google/Outlook (e.g., Gmail's message ID)"""
  provider_email_id: String
  """The thread ID from the provider"""
  thread_id: String
  """Sender's email address"""
  from_email: String
  """JSON array of recipient email addresses"""
  to_emails: JSON
  """JSON array of CC recipient email addresses"""
  cc_emails: JSON
  """JSON array of BCC recipient email addresses"""
  bcc_emails: JSON
  """Email subject line"""
  subject: String
  """A short preview/snippet of the email body"""
  snippet: String
  """The internal date/time from the email provider"""
  internal_date: DateTime
  """Timestamp when your system ingested this email"""
  received_at: Timestamp
  """Whether the email is marked as read"""
  is_read: Int
  """JSON array of label IDs (e.g., 'INBOX', 'SENT', 'STARRED')"""
  label_ids: JSON
  """Current status of the email in the mailbox"""
  status: user_emails_status
  """SHA256 hash of the full email body to detect changes (optional)"""
  raw_body_hash: String
  created_at: Timestamp
  updated_at: Timestamp
}

input user_preferences_InsertInput {
  """Unique ID for the preference record (UUID)"""
  id: String!
  """Foreign key linking to the users table"""
  user_id: String!
  """
  Key for the specific preference (e.g., 'ai_tone', 'auto_summarize', 'email_unwanted_senders')
  """
  preference_key: String!
  """
  Value of the preference (e.g., 'professional', 'true', '15', '["spam.com", "newsletter.net"]')
  """
  preference_value: String
  created_at: Timestamp
  updated_at: Timestamp
}

input user_preferences_UpdateInput {
  """Unique ID for the preference record (UUID)"""
  id: String
  """Foreign key linking to the users table"""
  user_id: String
  """
  Key for the specific preference (e.g., 'ai_tone', 'auto_summarize', 'email_unwanted_senders')
  """
  preference_key: String
  """
  Value of the preference (e.g., 'professional', 'true', '15', '["spam.com", "newsletter.net"]')
  """
  preference_value: String
  created_at: Timestamp
  updated_at: Timestamp
}

input users_InsertInput {
  """
  Unique user ID (UUID) generated by NextAuth.js for your application's internal use
  """
  id: String!
  """User's display name, typically from the OAuth provider (e.g., Google)"""
  name: String
  """
  User's primary email address, typically from the OAuth provider (e.g., Google)
  """
  email: String!
  """Timestamp when the email was verified (e.g., via OAuth login)"""
  email_verified: DateTime
  """URL to user's profile picture from the OAuth provider"""
  image: String
  """Timestamp when the user record was created"""
  created_at: Timestamp
  """Timestamp when the user record was last updated"""
  updated_at: Timestamp
  """Last time user data was polled for new emails/events"""
  last_synced_at: DateTime
  has_synced: Int
}

input users_UpdateInput {
  """
  Unique user ID (UUID) generated by NextAuth.js for your application's internal use
  """
  id: String
  """User's display name, typically from the OAuth provider (e.g., Google)"""
  name: String
  """
  User's primary email address, typically from the OAuth provider (e.g., Google)
  """
  email: String
  """Timestamp when the email was verified (e.g., via OAuth login)"""
  email_verified: DateTime
  """URL to user's profile picture from the OAuth provider"""
  image: String
  """Timestamp when the user record was created"""
  created_at: Timestamp
  """Timestamp when the user record was last updated"""
  updated_at: Timestamp
  """Last time user data was polled for new emails/events"""
  last_synced_at: DateTime
  has_synced: Int
}